{"version":3,"sources":["../src/common/dotlottie-state-machine-common.ts","../src/common/dotlottie-state.ts","../src/common/manifest.ts","../src/common/utils.ts","../src/lottie-state-machine.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { ZipOptions } from 'fflate';\nimport { safeParse, flatten } from 'valibot';\n\nimport {\n  DotLottieStatesSchema,\n  type DotLottieStates,\n  type DotLottieStateMachineDescriptor,\n  DotLottieStateMachineDescriptorSchema,\n} from './dotlottie-state';\nimport { DotLottieError, ErrorCodes, createError } from './utils';\n\nexport interface DotLottieStateMachineCommonOptions {\n  descriptor: DotLottieStateMachineDescriptor;\n  states: DotLottieStates;\n  zipOptions?: ZipOptions;\n}\n\nexport class DotLottieStateMachineCommon {\n  protected _descriptor: DotLottieStateMachineDescriptor;\n\n  protected _zipOptions: ZipOptions;\n\n  protected _states: DotLottieStates;\n\n  public constructor(options: DotLottieStateMachineCommonOptions) {\n    this._requireValidId(options.descriptor.id);\n    this._requireValidStates(options.states);\n    this._requireValidDescriptor(options.descriptor);\n\n    this._descriptor = options.descriptor;\n\n    this._zipOptions = options.zipOptions ?? {};\n\n    this._states = options.states;\n  }\n\n  public get zipOptions(): ZipOptions {\n    return this._zipOptions;\n  }\n\n  public set zipOptions(zipOptions: ZipOptions) {\n    this._zipOptions = zipOptions;\n  }\n\n  public get id(): string {\n    return this._descriptor.id;\n  }\n\n  public set id(id: string) {\n    this._requireValidId(id);\n\n    this._descriptor.id = id;\n  }\n\n  public get states(): DotLottieStates {\n    return this._states;\n  }\n\n  public set states(states: DotLottieStates) {\n    this._states = states;\n  }\n\n  public get initial(): string {\n    return this._descriptor.initial;\n  }\n\n  public set initial(initial: string) {\n    this._descriptor.initial = initial;\n  }\n\n  public get descriptor(): DotLottieStateMachineDescriptor {\n    return this._descriptor;\n  }\n\n  public set descriptor(descriptor: DotLottieStateMachineDescriptor) {\n    this._descriptor = descriptor;\n  }\n\n  public toString(): string {\n    return JSON.stringify({\n      descriptor: this._descriptor,\n      states: this._states,\n    });\n  }\n\n  protected _requireValidId(id: string | undefined): void {\n    if (!id) {\n      throw createError('Invalid id.');\n    }\n  }\n\n  protected _requireValidDescriptor(descriptor: DotLottieStateMachineDescriptor): void {\n    const result = safeParse(DotLottieStateMachineDescriptorSchema, descriptor);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.error).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid descriptor: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n\n  protected _requireValidStates(states: DotLottieStates): void {\n    const result = safeParse(DotLottieStatesSchema, states);\n\n    if (!result.success) {\n      const error = `Invalid state machine declaration, ${JSON.stringify(flatten(result.error).nested, null, 2)}`;\n\n      throw new DotLottieError(`Invalid states: ${error}`, ErrorCodes.INVALID_STATEMACHINE);\n    }\n  }\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport type { Output } from 'valibot';\nimport {\n  merge,\n  number,\n  object,\n  optional,\n  string,\n  union,\n  omit,\n  record,\n  tuple,\n  maxValue,\n  minValue,\n  array,\n} from 'valibot';\n\nimport { ManifestAnimationSchema } from './manifest';\n\nexport const PlaybackOptionsSchema = omit(ManifestAnimationSchema, ['id']);\n\nexport type PlaybackOptions = Output<typeof PlaybackOptionsSchema>;\n\nexport const TransitionableSchema = object({\n  state: string(),\n});\nexport type Transitionable = Output<typeof TransitionableSchema>;\n\nexport const StateTransitionOnClickSchema = TransitionableSchema;\n\nexport type StateTransitionOnClick = Output<typeof StateTransitionOnClickSchema>;\n\nexport const StateTransitionOnAfterSchema = merge([TransitionableSchema, object({ ms: number() })]);\n\nexport type StateTransitionOnAfter = Output<typeof StateTransitionOnAfterSchema>;\n\nexport const StateTransitionOnEnterSchema = merge([TransitionableSchema, object({ count: number() })]);\n\nexport type StateTransitionOnEnter = Output<typeof StateTransitionOnEnterSchema>;\n\nexport const StateTransitionOnMouseEnterSchema = TransitionableSchema;\n\nexport type StateTransitionOnMouseEnter = Output<typeof StateTransitionOnMouseEnterSchema>;\n\nexport const StateTransitionOnMouseLeaveSchema = TransitionableSchema;\n\nexport type StateTransitionOnMouseLeave = Output<typeof StateTransitionOnMouseLeaveSchema>;\n\nexport const StateTransitionOnCompleteSchema = TransitionableSchema;\n\nexport type StateTransitionOnComplete = Output<typeof StateTransitionOnCompleteSchema>;\n\nexport const StateTransitionOnShowSchema = merge([\n  TransitionableSchema,\n  object({ threshold: optional(array(number([minValue(0), maxValue(1)]))) }),\n]);\nexport type StateTransitionOnShow = Output<typeof StateTransitionOnShowSchema>;\n\nexport const DotLottieStateTransitionEventsSchema = object({\n  onAfter: optional(StateTransitionOnAfterSchema),\n  onClick: optional(StateTransitionOnClickSchema),\n  onComplete: optional(StateTransitionOnCompleteSchema),\n  onEnter: optional(StateTransitionOnEnterSchema),\n  onMouseEnter: optional(StateTransitionOnMouseEnterSchema),\n  onMouseLeave: optional(StateTransitionOnMouseLeaveSchema),\n  onShow: optional(StateTransitionOnShowSchema),\n});\nexport type DotLottieStateTransitionEvents = Output<typeof DotLottieStateTransitionEventsSchema>;\n\nexport const DotLottieStatePlaybackSettingsSchema = merge([\n  PlaybackOptionsSchema,\n  object({\n    playOnScroll: optional(tuple([number([minValue(0), maxValue(1)]), number([minValue(0), maxValue(1)])])),\n    segments: optional(union([tuple([number(), number()]), string()])),\n  }),\n]);\nexport type DotLottieStatePlaybackSettings = Output<typeof DotLottieStatePlaybackSettingsSchema>;\n\nexport const DotLottieStateSchema = merge([\n  DotLottieStateTransitionEventsSchema,\n  object({\n    animationId: optional(string()),\n    playbackSettings: DotLottieStatePlaybackSettingsSchema,\n  }),\n]);\nexport type DotLottieState = Output<typeof DotLottieStateSchema>;\n\nexport const DotLottieStatesSchema = record(string(), DotLottieStateSchema);\nexport type DotLottieStates = Output<typeof DotLottieStatesSchema>;\n\nexport const DotLottieStateMachineDescriptorSchema = object({\n  id: string(),\n  initial: string(),\n});\nexport type DotLottieStateMachineDescriptor = Output<typeof DotLottieStateMachineDescriptorSchema>;\n\nexport const DotLottieStateMachineSchema = object({\n  descriptor: DotLottieStateMachineDescriptorSchema,\n  states: DotLottieStatesSchema,\n});\nexport type DotLottieStateMachine = Output<typeof DotLottieStateMachineSchema>;\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport {\n  object,\n  type Output,\n  string,\n  array,\n  boolean,\n  number,\n  union,\n  optional,\n  record,\n  any,\n  nativeEnum,\n  literal,\n} from 'valibot';\n\nexport enum PlayMode {\n  Bounce = 'bounce',\n  Normal = 'normal',\n}\n\nexport const PlayModeSchema = nativeEnum(PlayMode);\n\nexport const ManifestAnimationSchema = object({\n  autoplay: optional(boolean()),\n  defaultTheme: optional(string()),\n  direction: optional(union([literal(1), literal(-1)])),\n  hover: optional(boolean()),\n  id: string(),\n  intermission: optional(number()),\n  loop: optional(union([boolean(), number()])),\n  playMode: optional(PlayModeSchema),\n  speed: optional(number()),\n  themeColor: optional(string()),\n});\nexport type ManifestAnimation = Output<typeof ManifestAnimationSchema>;\n\nexport const ManifestThemeSchema = object({\n  animations: array(string()),\n  id: string(),\n});\nexport type ManifestTheme = Output<typeof ManifestThemeSchema>;\n\nexport const ManifestSchema = object({\n  activeAnimationId: optional(string()),\n  animations: array(ManifestAnimationSchema),\n  author: optional(string()),\n  custom: optional(record(string(), any())),\n  description: optional(string()),\n  generator: optional(string()),\n  keywords: optional(string()),\n  revision: optional(number()),\n  themes: optional(array(ManifestThemeSchema)),\n  states: optional(array(string())),\n  version: optional(string()),\n});\n\nexport type Manifest = Output<typeof ManifestSchema>;\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\n/* eslint-disable guard-for-in */\n\nimport type { Animation as AnimationData, Asset } from '@lottiefiles/lottie-types';\nimport type { UnzipFileFilter, Unzipped } from 'fflate';\nimport { unzip as fflateUnzip, strFromU8 } from 'fflate';\nimport { flatten, safeParse } from 'valibot';\n\nimport type { LottieStateMachine } from '../lottie-state-machine';\n\nimport type { Manifest } from './manifest';\nimport { ManifestSchema } from './manifest';\n\nexport interface MimeTypes {\n  [key: string]: string;\n}\n\nexport interface MimeCodes {\n  [key: string]: number[];\n}\n\nexport const MIME_TYPES: MimeTypes = {\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  gif: 'image/gif',\n  bmp: 'image/bmp',\n  svg: 'image/svg+xml',\n  svgxml: 'image/svg+xml',\n  webp: 'image/webp',\n  mp3: 'audio/mp3',\n};\n\nexport const MIME_CODES: MimeCodes = {\n  jpeg: [0xff, 0xd8, 0xff],\n  png: [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a],\n  gif: [0x47, 0x49, 0x46],\n  bmp: [0x42, 0x4d],\n  webp: [0x52, 0x49, 0x46, 0x46, 0x3f, 0x3f, 0x3f, 0x3f, 0x57, 0x45, 0x42, 0x50],\n  // This covers <svg..\n  svg: [0x3c, 0x73, 0x76, 0x67],\n  // This covers <?xml..\n  svgxml: [0x3c, 0x3f, 0x78, 0x6d, 0x6c],\n  mp3: [0x49, 0x44, 0x33],\n};\n\nexport interface MimeToExtension {\n  [key: string]: string;\n}\n\nexport const MIME_TO_EXTENSION: MimeToExtension = {\n  'image/jpeg': 'jpeg',\n  'image/png': 'png',\n  'image/gif': 'gif',\n  'image/bmp': 'bmp',\n  'image/svg+xml': 'svg',\n  'image/webp': 'webp',\n  'audio/mpeg': 'mpeg',\n  'audio/mp3': 'mp3',\n};\n\nexport enum ErrorCodes {\n  ASSET_NOT_FOUND = 'ASSET_NOT_FOUND',\n  INVALID_DOTLOTTIE = 'INVALID_DOTLOTTIE',\n  INVALID_STATEMACHINE = 'INVALID_STATEMACHINE',\n  INVALID_URL = 'INVALID_URL',\n}\n\nexport class DotLottieError extends Error {\n  public code: ErrorCodes | undefined;\n\n  public constructor(message: string, code?: ErrorCodes) {\n    super(message);\n    this.name = '[dotlottie-js]';\n    this.code = code;\n  }\n}\n\n/**\n * Creates an Error object with the specified message.\n *\n * @remarks\n * This function accepts a message string and constructs a new Error object prefixed with \"[dotlottie-js]: \".\n *\n * @deprecated\n * This function has been deprecated in favor of using the {@link DotLottieError} class directly.\n *\n * @param message - The error message to include in the Error object.\n * @returns An Error object with the specified message, prefixed with \"[dotlottie-js]: \".\n *\n * @example\n * ```typescript\n * const message = 'DotLottie not found';\n * const error = createError(message);\n * ```\n *\n * @public\n */\nexport const createError = (message: string): Error => {\n  const error = new Error(`[dotlottie-js]: ${message}`);\n\n  return error;\n};\n\n/**\n * Converts a base64 string into a Uint8Array.\n *\n * @remarks\n * This function accepts a base64 string and returns a Uint8Array containing the decoded bytes.\n *\n * @param base64String - The base64-encoded string to decode.\n * @returns A Uint8Array containing the decoded bytes.\n *\n * @example\n * ```typescript\n * const base64 = 'SGVsbG8gd29ybGQ=';\n * const array = base64ToUint8Array(base64);\n * ```\n *\n * @public\n */\nexport const base64ToUint8Array = (base64String: string): Uint8Array => {\n  const withoutMeta = base64String.substring(base64String.indexOf(',') + 1);\n  const binaryString =\n    typeof window === 'undefined' ? Buffer.from(withoutMeta, 'base64').toString('binary') : atob(withoutMeta);\n\n  const uint8Array = new Uint8Array(binaryString.length);\n\n  for (let i = 0; i < binaryString.length; i += 1) {\n    uint8Array[i] = binaryString.charCodeAt(i);\n  }\n\n  return uint8Array;\n};\n\n/**\n * Determines the MIME type from a base64-encoded string.\n *\n * @remarks\n * This function accepts a base64-encoded string and determines its MIME type by looking at the first few bytes.\n *\n * @param base64 - The base64-encoded string to analyze.\n * @returns The MIME type as a string, or null if the type cannot be determined.\n *\n * @example\n * ```typescript\n * const base64 = 'data:image/jpeg;base64,...';\n * const mimeType = getMimeTypeFromBase64(base64);\n * ```\n *\n * @public\n */\nexport const getMimeTypeFromBase64 = (base64: string): string | undefined => {\n  let data: string | null = null;\n  let bytes: number[] = [];\n\n  if (!base64) {\n    throw new DotLottieError(\n      'Failed to determine the MIME type from the base64 asset string. Please check the input data. Supported asset types for dotlottie-js  are: jpeg, png, gif, bmp, svg, webp, mp3',\n      ErrorCodes.INVALID_DOTLOTTIE,\n    );\n  }\n\n  const withoutMeta = base64.substring(base64.indexOf(',') + 1);\n\n  if (typeof window === 'undefined') {\n    data = Buffer.from(withoutMeta, 'base64').toString('binary');\n  } else {\n    data = atob(withoutMeta);\n  }\n\n  const bufData = new Uint8Array(data.length);\n\n  for (let i = 0; i < data.length; i += 1) {\n    bufData[i] = data.charCodeAt(i);\n  }\n\n  for (const mimeType in MIME_CODES) {\n    const dataArr = MIME_CODES[mimeType];\n\n    if (mimeType === 'webp' && dataArr && bufData.length > dataArr.length) {\n      const riffHeader = Array.from(bufData.subarray(0, 4));\n      const webpFormatMarker = Array.from(bufData.subarray(8, 12));\n\n      if (\n        riffHeader.every((byte, index) => byte === dataArr[index]) &&\n        webpFormatMarker.every((byte, index) => byte === dataArr[index + 8])\n      ) {\n        return MIME_TYPES[mimeType];\n      }\n    } else {\n      bytes = Array.from(bufData.subarray(0, dataArr?.length));\n\n      if (dataArr && bytes.every((byte, index) => byte === dataArr[index])) {\n        return MIME_TYPES[mimeType];\n      }\n    }\n  }\n\n  throw new DotLottieError(\n    'Failed to determine the MIME type from the base64 asset string. Please check the input data. Supported asset types for dotlottie-js  are: jpeg, png, gif, bmp, svg, webp, mp3',\n    ErrorCodes.INVALID_DOTLOTTIE,\n  );\n};\n\n/**\n * Determines the file extension from a base64-encoded string.\n *\n * @remarks\n * This function accepts a base64-encoded string and determines its file extension by examining the MIME type.\n *\n * @param base64 - The base64-encoded string to analyze.\n * @returns The file extension as a string, or 'png' if the extension cannot be determined.\n *\n * @example\n * ```typescript\n * const base64 = 'data:image/jpeg;base64,...';\n * const extension = getExtensionTypeFromBase64(base64);\n * ```\n *\n * @public\n */\nexport const getExtensionTypeFromBase64 = (base64: string): string | null => {\n  const mimeType = getMimeTypeFromBase64(base64);\n\n  if (!mimeType) {\n    const ext = base64.split(';')[0]?.split('/')[1];\n\n    if (ext) {\n      return MIME_TO_EXTENSION[ext] || null;\n    }\n\n    return null;\n  }\n\n  return MIME_TO_EXTENSION[mimeType] || null;\n};\n\n/**\n * Validates a given URL string.\n *\n * @remarks\n * This function accepts a URL string and checks whether it's a valid URL according to the URL constructor.\n * It returns `true` if the URL is valid, `false` otherwise.\n *\n * @param url - The URL string to validate.\n * @returns `true` if the URL is valid, `false` otherwise.\n *\n * @example\n * ```typescript\n * const url = 'https://example.com';\n * const isValid = isValidURL(url); // true\n * ```\n *\n * @public\n */\nexport const isValidURL = (url: string): boolean => {\n  try {\n    // eslint-disable-next-line no-new\n    new URL(url);\n\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Creates a data URL from a Uint8Array.\n *\n * @remarks\n * This function accepts a Uint8Array and a file extension, then converts the Uint8Array into a base64 data URL string.\n * The mimeType is determined based on the provided file extension, or defaults to 'image/png' if the extension is not recognized.\n *\n * @param uint8Data - The Uint8Array containing the binary data.\n * @param fileExtension - The file extension used to determine the mimeType (e.g., 'png', 'jpeg').\n * @returns The data URL string.\n *\n * @example\n * ```typescript\n * const uint8Data = new Uint8Array(...);\n * const fileExtension = 'png';\n * const dataUrl = dataUrlFromU8(uint8Data, fileExtension);\n * ```\n */\nexport function dataUrlFromU8(uint8Data: Uint8Array): string {\n  let base64: string;\n\n  if (typeof window === 'undefined') {\n    // Using Node.js Buffer for non-browser environments\n    base64 = Buffer.from(uint8Data).toString('base64');\n  } else {\n    // Using window.btoa for browser environments\n    const binaryString = Array.prototype.map.call(uint8Data, (byte: number) => String.fromCharCode(byte)).join('');\n\n    base64 = window.btoa(binaryString);\n  }\n\n  const mimeType = getMimeTypeFromBase64(base64);\n\n  return `data:${mimeType};base64,${base64}`;\n}\n\n/**\n * Checks if an asset is an image asset.\n *\n * @remarks\n * This function accepts an asset object and determines whether it represents an image asset.\n * It returns `true` if it's an image asset, `false` otherwise.\n *\n * @param asset - The asset object to check.\n * @returns `true` if it's an image asset, `false` otherwise.\n *\n * @example\n * ```typescript\n * const asset = { w: 100, h: 100, p: 'image.png' };\n * const isImage = isImageAsset(asset); // true\n * ```\n *\n * @public\n */\nexport function isImageAsset(asset: Asset.Value): asset is Asset.Image {\n  return 'w' in asset && 'h' in asset && !('xt' in asset) && 'p' in asset;\n}\n\n/**\n * Checks if an asset is an audio asset.\n *\n * @remarks\n * This function accepts an asset object and determines whether it represents an audio asset.\n * It returns `true` if it's an audio asset, `false` otherwise.\n *\n * @param asset - The asset object to check.\n * @returns `true` if it's an audio asset, `false` otherwise.\n *\n * @example\n * ```typescript\n * const asset = { e: 0, u: 'music/', p: 'audio.mp3' };\n * const isAudio = isAudioAsset(asset); // true\n * ```\n *\n * @public\n */\nexport function isAudioAsset(asset: Asset.Value): asset is Asset.Image {\n  return !('h' in asset) && !('w' in asset) && 'p' in asset && 'e' in asset && 'u' in asset && 'id' in asset;\n}\n\n/**\n * Unzips the .lottie file.\n *\n * @remarks\n * This function accepts a .lottie file as a Uint8Array and an optional filter function to refine the unzipping process.\n * It returns a Promise that resolves with the unzipped data.\n *\n * @param dotLottie - The .lottie data as a Uint8Array.\n * @param filter - The filter function to apply to the files. Defaults to a function that always returns true.\n * @returns A Promise that resolves with the unzipped data.\n * @throws {@link DotLottieError} if the .lottie data is not provided or is invalid.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const unzippedData = await unzipDotLottie(dotLottie);\n * ```\n *\n * @public\n */\nexport async function unzipDotLottie(\n  dotLottie: Uint8Array | undefined,\n  filter: UnzipFileFilter = (): boolean => true,\n): Promise<Unzipped> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    throw new DotLottieError('DotLottie not found', ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  const unzipped = await new Promise<Unzipped>((resolve, reject) => {\n    fflateUnzip(dotLottie, { filter }, (err, data) => {\n      if (err) {\n        reject(err);\n      }\n      resolve(data);\n    });\n  });\n\n  return unzipped;\n}\n\n/**\n * Unzips a specific file from a `.lottie` archive.\n *\n * @remarks\n * This function accepts a `.lottie` file as a `Uint8Array`, a path string representing the\n * target file to extract, and an optional filter function to further refine the extraction.\n * It returns a `Promise` that resolves to the unzipped `Uint8Array` of the target file.\n *\n * @param dotLottie - The `.lottie` file content as a `Uint8Array`.\n * @param path - The path of the target file within the `.lottie` archive to extract.\n * @param filter - An optional filter function to apply on the unzipping process.\n *                 Accepts a file object and returns a boolean indicating whether the file should be included.\n * @returns A `Promise` that resolves to the `Uint8Array` of the unzipped target file.\n *\n * @throws {@link DotLottieError} if the input is not a valid `.lottie` file or if the target file is not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const targetPath = 'images/image.png';\n * const unzippedFile = await unzipDotLottieFile(dotLottie, targetPath);\n * ```\n *\n * @public\n */\nexport async function unzipDotLottieFile(\n  dotLottie: Uint8Array,\n  path: string,\n  filter?: UnzipFileFilter,\n): Promise<Uint8Array | undefined> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    throw new DotLottieError('DotLottie not found', ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  const unzipped = await unzipDotLottie(dotLottie, (file) => file.name === path && (!filter || filter(file)));\n\n  return unzipped[path];\n}\n\n/**\n * Retrieves the manifest data from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and extracts the manifest data from it.\n * The manifest contains metadata information about the .lottie file, such as the list of animations, themes, and image assets.\n * It returns a Promise that resolves to the manifest data or `undefined` if the manifest is not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @returns A Promise that resolves with the manifest data or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const manifestData = await getManifest(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getManifest(dotLottie: Uint8Array): Promise<Manifest | undefined> {\n  const manifestFileName = 'manifest.json';\n\n  const unzipped = await unzipDotLottie(dotLottie, (file) => file.name === manifestFileName);\n\n  const unzippedManifest = unzipped[manifestFileName];\n\n  if (typeof unzippedManifest === 'undefined') {\n    return undefined;\n  }\n\n  return JSON.parse(strFromU8(unzippedManifest, false)) as Manifest;\n}\n\n/**\n * Validates the provided DotLottie data.\n *\n * @remarks\n * This function accepts a Uint8Array containing .lottie data and validates its structure and content.\n * It returns a Promise that resolves with an object containing a success boolean and an optional error string.\n *\n * @param dotLottie - The DotLottie data as a Uint8Array.\n * @returns A Promise that resolves with an object containing a success boolean and an optional error string.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const validationResult = await validateDotLottie(dotLottie);\n * ```\n *\n * @public\n */\nexport async function validateDotLottie(dotLottie: Uint8Array): Promise<{ error?: string; success: boolean }> {\n  if (!(dotLottie instanceof Uint8Array)) {\n    return { success: false, error: 'DotLottie not found' };\n  }\n\n  const manifest = await getManifest(dotLottie);\n\n  if (typeof manifest === 'undefined') {\n    return { success: false, error: 'Invalid .lottie file, manifest.json is missing' };\n  }\n\n  const manifestValidationResult = safeParse(ManifestSchema, manifest);\n\n  if (!manifestValidationResult.success) {\n    const error = `Invalid .lottie file, manifest.json structure is invalid, ${JSON.stringify(\n      flatten(manifestValidationResult.error).nested,\n      null,\n      2,\n    )}`;\n\n    return { success: false, error };\n  }\n\n  return { success: true };\n}\n\n/**\n * Loads a .lottie file from an ArrayBuffer.\n *\n * @remarks\n * This function takes an ArrayBuffer containing .lottie data and converts it into a Uint8Array.\n * It validates the data and returns a Promise that resolves with the DotLottie data as a Uint8Array.\n *\n * @param arrayBuffer - The ArrayBuffer containing .lottie data.\n * @returns A Promise that resolves with the DotLottie data as a Uint8Array.\n * @throws {@link DotLottieError} if the data is invalid.\n *\n * @example\n * ```typescript\n * const arrayBuffer = new ArrayBuffer(...);\n * const dotLottie = await loadFromArrayBuffer(arrayBuffer);\n * ```\n *\n * @public\n */\nexport async function loadFromArrayBuffer(arrayBuffer: ArrayBuffer): Promise<Uint8Array> {\n  const dotLottie = new Uint8Array(arrayBuffer);\n\n  const validationResult = await validateDotLottie(dotLottie);\n\n  if (validationResult.error) {\n    throw new DotLottieError(validationResult.error, ErrorCodes.INVALID_DOTLOTTIE);\n  }\n\n  return dotLottie;\n}\n\n/**\n * Loads a .lottie file from a given URL.\n *\n * @remarks\n * This function takes a URL string as input and fetches the .lottie file from the provided URL.\n * It returns a Promise that resolves with the DotLottie data as a Uint8Array.\n *\n * @param src - The URL source of the .lottie file.\n * @returns A Promise that resolves with the DotLottie data as a Uint8Array.\n * @throws {@link DotLottieError} if the URL is invalid or if the content type is incorrect.\n *\n * @example\n * ```typescript\n * const url = 'https://example.com/animation.lottie';\n * const dotLottie = await loadFromURL(url);\n * ```\n *\n * @public\n */\nexport async function loadFromURL(src: string): Promise<Uint8Array> {\n  if (!isValidURL(src)) {\n    throw new DotLottieError('Invalid url provided for .lottie file', ErrorCodes.INVALID_URL);\n  }\n\n  const response = await fetch(src);\n\n  const arrayBuffer = await response.arrayBuffer();\n\n  const contentType = response.headers.get('content-type');\n\n  if (!['application/zip', 'application/octet-stream'].includes(contentType || '')) {\n    throw new DotLottieError(\n      `Invalid content type for .lottie file, expected application/zip or application/octet-stream, received ${contentType}`,\n      ErrorCodes.INVALID_DOTLOTTIE,\n    );\n  }\n\n  const dotLottie = await loadFromArrayBuffer(arrayBuffer);\n\n  return dotLottie;\n}\n\n/**\n * Retrieves an audio from the given DotLottie object by its filename.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the filename of the audio to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the audio data URL or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filename - The filename of the image to get.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves with the audio data URL or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const filename = 'alarm.mp3';\n * const imageData = await getAudio(dotLottie, filename);\n * ```\n *\n * @public\n */\nexport async function getAudio(\n  dotLottie: Uint8Array,\n  filename: string,\n  filter?: UnzipFileFilter,\n): Promise<string | undefined> {\n  const audioFilename = `audio/${filename}`;\n\n  const unzipped = await unzipDotLottieFile(dotLottie, audioFilename, filter);\n\n  if (typeof unzipped === 'undefined') {\n    return undefined;\n  }\n\n  return dataUrlFromU8(unzipped);\n}\n\n/**\n * Retrieves all audio files from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to further refine the extraction.\n * It returns a Promise that resolves to a record containing the audio data URLs mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves to a record containing the audio data URLs mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const allAudio = await getAllAudio(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getAllAudio(dotLottie: Uint8Array, filter?: UnzipFileFilter): Promise<Record<string, string>> {\n  const unzippedAudio = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('audio/', '');\n\n    return file.name.startsWith('audio/') && (!filter || filter({ ...file, name }));\n  });\n\n  const audio: Record<string, string> = {};\n\n  for (const audioPath in unzippedAudio) {\n    const unzippedSingleAudio = unzippedAudio[audioPath];\n\n    if (unzippedSingleAudio instanceof Uint8Array) {\n      const audioId = audioPath.replace('audio/', '');\n\n      audio[audioId] = dataUrlFromU8(unzippedSingleAudio);\n    }\n  }\n\n  return audio;\n}\n\n/**\n * Inlines audio assets for the given animations within a DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and a record containing the animations to process.\n * It identifies the audio used in the animations and replaces their references with the actual audio data.\n * This operation is performed asynchronously, and the function returns a Promise that resolves when the operation is complete.\n *\n * @param dotLottie - The DotLottie object containing the animations.\n * @param animations - A record containing the animations to process.\n * @returns A Promise that resolves when the operation is complete, returning nothing.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = { animation1: {...}, animation2: {...} };\n * await inlineAudioAssets(dotLottie, animations);\n * ```\n *\n * @public\n */\nexport async function inlineAudioAssets(\n  dotLottie: Uint8Array,\n  animations: Record<string, AnimationData>,\n): Promise<void> {\n  const audioMap = new Map<string, Set<string>>();\n\n  for (const [animationId, animationData] of Object.entries(animations)) {\n    for (const asset of animationData.assets || []) {\n      if (isAudioAsset(asset)) {\n        const audioId = asset.p;\n\n        if (!audioMap.has(audioId)) {\n          audioMap.set(audioId, new Set());\n        }\n        audioMap.get(audioId)?.add(animationId);\n      }\n    }\n  }\n\n  const unzippedAudio = await getAllAudio(dotLottie, (file) => audioMap.has(file.name));\n\n  for (const [audioId, animationIdsSet] of audioMap) {\n    const audioDataURL = unzippedAudio[audioId];\n\n    if (audioDataURL) {\n      for (const animationId of animationIdsSet) {\n        const animationData = animations[animationId];\n\n        for (const asset of animationData?.assets || []) {\n          if (isAudioAsset(asset) && asset.p === audioId) {\n            asset.p = audioDataURL;\n            asset.u = '';\n            asset.e = 1;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves an image from the given DotLottie object by its filename.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the filename of the image to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the image data URL or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filename - The filename of the image to get.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves with the image data URL or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const filename = 'image.png';\n * const imageData = await getImage(dotLottie, filename);\n * ```\n *\n * @public\n */\nexport async function getImage(\n  dotLottie: Uint8Array,\n  filename: string,\n  filter?: UnzipFileFilter,\n): Promise<string | undefined> {\n  const imageFilename = `images/${filename}`;\n\n  const unzipped = await unzipDotLottieFile(dotLottie, imageFilename, filter);\n\n  if (typeof unzipped === 'undefined') {\n    return undefined;\n  }\n\n  return dataUrlFromU8(unzipped);\n}\n\n/**\n * Retrieves all images from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to further refine the extraction.\n * It returns a Promise that resolves to a record containing the image data URLs mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param filter - An optional filter function to apply on the unzipping process.\n * @returns A Promise that resolves to a record containing the image data URLs mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const images = await getImages(dotLottie);\n * ```\n *\n * @public\n */\nexport async function getImages(dotLottie: Uint8Array, filter?: UnzipFileFilter): Promise<Record<string, string>> {\n  const unzippedImages = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('images/', '');\n\n    return file.name.startsWith('images/') && (!filter || filter({ ...file, name }));\n  });\n\n  const images: Record<string, string> = {};\n\n  for (const imagePath in unzippedImages) {\n    const unzippedImage = unzippedImages[imagePath];\n\n    if (unzippedImage instanceof Uint8Array) {\n      const imageId = imagePath.replace('images/', '');\n\n      images[imageId] = dataUrlFromU8(unzippedImage);\n    }\n  }\n\n  return images;\n}\n\n/**\n * Inlines image assets for the given animations within a DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and a record containing the animations to process.\n * It identifies the images used in the animations and replaces their references with the actual image data.\n * This operation is performed asynchronously, and the function returns a Promise that resolves when the operation is complete.\n *\n * @param dotLottie - The DotLottie object containing the animations.\n * @param animations - A record containing the animations to process.\n * @returns A Promise that resolves when the operation is complete, returning nothing.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = { animation1: {...}, animation2: {...} };\n * await inlineImageAssets(dotLottie, animations);\n * ```\n *\n * @public\n */\nexport async function inlineImageAssets(\n  dotLottie: Uint8Array,\n  animations: Record<string, AnimationData>,\n): Promise<void> {\n  const imagesMap = new Map<string, Set<string>>();\n\n  for (const [animationId, animationData] of Object.entries(animations)) {\n    for (const asset of animationData.assets || []) {\n      if (isImageAsset(asset)) {\n        const imageId = asset.p;\n\n        if (!imagesMap.has(imageId)) {\n          imagesMap.set(imageId, new Set());\n        }\n        imagesMap.get(imageId)?.add(animationId);\n      }\n    }\n  }\n\n  const unzippedImages = await getImages(dotLottie, (file) => imagesMap.has(file.name));\n\n  for (const [imageId, animationIdsSet] of imagesMap) {\n    const imageDataURL = unzippedImages[imageId];\n\n    if (imageDataURL) {\n      for (const animationId of animationIdsSet) {\n        const animationData = animations[animationId];\n\n        for (const asset of animationData?.assets || []) {\n          if (isImageAsset(asset) && asset.p === imageId) {\n            asset.p = imageDataURL;\n            asset.u = '';\n            asset.e = 1;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Retrieves an animation from the given DotLottie object by its ID.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the animation ID to retrieve, and an optional inlineAssets option.\n * It returns a Promise that resolves to the animation data or `undefined` if not found.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param animationId - The animation ID to get.\n * @param options - An object containing an optional `inlineAssets` boolean to control whether image assets should be inlined.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves with the animation data or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animationId = 'example';\n * const animationData = await getAnimation(dotLottie, animationId, { inlineAssets: true });\n * ```\n *\n * @public\n */\nexport async function getAnimation(\n  dotLottie: Uint8Array,\n  animationId: string,\n  { inlineAssets }: { inlineAssets?: boolean } = {},\n  filter?: UnzipFileFilter,\n): Promise<AnimationData | undefined> {\n  const animationFilename = `animations/${animationId}.json`;\n\n  const unzippedAnimation = await unzipDotLottieFile(dotLottie, animationFilename, filter);\n\n  if (typeof unzippedAnimation === 'undefined') {\n    return undefined;\n  }\n\n  const animationData = JSON.parse(strFromU8(unzippedAnimation, false)) as AnimationData;\n\n  if (!inlineAssets) {\n    return animationData;\n  }\n\n  const animationsMap = {\n    [animationId]: animationData,\n  };\n\n  await inlineImageAssets(dotLottie, animationsMap);\n\n  await inlineAudioAssets(dotLottie, animationsMap);\n\n  return animationData;\n}\n\n/**\n * Retrieves the animations from the given DotLottie object, with optional filtering and asset inlining.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, an optional inlineAssets option, and an optional filter function.\n * It returns a Promise that resolves to a record containing the animation data mapped by their ID.\n *\n * @param dotLottie - The Uint8Array of DotLottie data.\n * @param options - An object containing an optional `inlineAssets` boolean to control whether assets should be inlined.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the animation data mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const animations = await getAnimations(dotLottie, { inlineAssets: true });\n * ```\n *\n * @public\n */\nexport async function getAnimations(\n  dotLottie: Uint8Array,\n  { inlineAssets }: { inlineAssets?: boolean } = {},\n  filter?: UnzipFileFilter,\n): Promise<Record<string, AnimationData>> {\n  const animationsMap: Record<string, AnimationData> = {};\n  const unzippedAnimations = await unzipDotLottie(dotLottie, (file) => {\n    const filename = file.name.replace('animations/', '').replace('.json', '');\n\n    return file.name.startsWith('animations/') && (!filter || filter({ ...file, name: filename }));\n  });\n\n  for (const animationPath in unzippedAnimations) {\n    const data = unzippedAnimations[animationPath];\n\n    if (data instanceof Uint8Array) {\n      const animationId = animationPath.replace('animations/', '').replace('.json', '');\n      const animationData = JSON.parse(strFromU8(data, false)) as AnimationData;\n\n      animationsMap[animationId] = animationData;\n    }\n  }\n\n  if (!inlineAssets) {\n    return animationsMap;\n  }\n\n  await inlineImageAssets(dotLottie, animationsMap);\n\n  return animationsMap;\n}\n\n/**\n * Retrieves the themes from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to refine the extraction of themes.\n * It returns a Promise that resolves to a record containing the themes mapped by their ID.\n *\n * @param dotLottie - The DotLottie object containing the themes.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the themes mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const themes = await getThemes(dotLottie);\n * ```\n */\nexport async function getThemes(\n  dotLottie: Uint8Array,\n  filter?: UnzipFileFilter,\n): Promise<Record<string, Record<string, unknown>>> {\n  const themesMap: Record<string, Record<string, unknown>> = {};\n\n  const unzippedThemes = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('themes/', '').replace('.json', '');\n\n    return file.name.startsWith('themes/') && (!filter || filter({ ...file, name }));\n  });\n\n  for (const themePath in unzippedThemes) {\n    const data = unzippedThemes[themePath];\n\n    if (data instanceof Uint8Array) {\n      const themeId = themePath.replace('themes/', '').replace('.json', '');\n\n      themesMap[themeId] = JSON.parse(strFromU8(data, false));\n    }\n  }\n\n  return themesMap;\n}\n\n/**\n * Retrieves a specific theme by ID from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the theme ID to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the theme as a string or `undefined` if not found.\n *\n * @param dotLottie - The DotLottie object containing the theme.\n * @param themeId - The ID of the theme to retrieve.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to the theme as a string or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const themeId = 'dark';\n * const theme = await getTheme(dotLottie, themeId);\n * ```\n */\nexport async function getTheme(\n  dotLottie: Uint8Array,\n  themeId: string,\n  filter?: UnzipFileFilter,\n): Promise<Record<string, unknown> | undefined> {\n  const themeFilename = `themes/${themeId}.json`;\n\n  const unzippedTheme = await unzipDotLottieFile(dotLottie, themeFilename, filter);\n\n  if (typeof unzippedTheme === 'undefined') {\n    return undefined;\n  }\n\n  return JSON.parse(strFromU8(unzippedTheme, false));\n}\n\n/**\n * Retrieves the state machines from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array and an optional filter function to refine the extraction of state machines.\n * It returns a Promise that resolves to a record containing the state machines mapped by their ID.\n *\n * @param dotLottie - The DotLottie object containing the state machines.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to a record containing the state machines mapped by their ID.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const machines = await getStateMachines(dotLottie);\n * ```\n */\nexport async function getStateMachines(\n  dotLottie: Uint8Array,\n  filter?: UnzipFileFilter,\n): Promise<Record<string, string>> {\n  const statesMap: Record<string, string> = {};\n\n  const unzippedStates = await unzipDotLottie(dotLottie, (file) => {\n    const name = file.name.replace('states/', '').replace('.json', '');\n\n    return file.name.startsWith('states/') && (!filter || filter({ ...file, name }));\n  });\n\n  for (const statePath in unzippedStates) {\n    const data = unzippedStates[statePath];\n\n    if (data instanceof Uint8Array) {\n      const themeId = statePath.replace('states/', '').replace('.json', '');\n\n      statesMap[themeId] = strFromU8(data, false);\n    }\n  }\n\n  return statesMap;\n}\n\n/**\n * Retrieves a specific state machine by ID from the given DotLottie object.\n *\n * @remarks\n * This function accepts a DotLottie object as a Uint8Array, the state ID to retrieve, and an optional filter function.\n * It returns a Promise that resolves to the state machine as a string or `undefined` if not found.\n *\n * @param dotLottie - The DotLottie object containing the theme.\n * @param stateMachineId - The ID of the state machine to retrieve.\n * @param filter - An optional function to filter the files to be unzipped.\n * @returns A Promise that resolves to the state machine as a string or `undefined` if not found.\n *\n * @example\n * ```typescript\n * const dotLottie = new Uint8Array(...);\n * const stateMachineId = 'walk';\n * const stateMachine = await getState(dotLottie, stateMachineId);\n * ```\n */\nexport async function getStateMachine(\n  dotLottie: Uint8Array,\n  stateMachineId: string,\n  filter?: UnzipFileFilter,\n): Promise<LottieStateMachine | undefined> {\n  const stateMachineFilename = `states/${stateMachineId}.json`;\n\n  const unzippedStateMachine = await unzipDotLottieFile(dotLottie, stateMachineFilename, filter);\n\n  if (typeof unzippedStateMachine === 'undefined') {\n    return undefined;\n  }\n\n  const stateMachine = JSON.parse(strFromU8(unzippedStateMachine, false)) as LottieStateMachine;\n\n  return stateMachine;\n}\n","/**\n * Copyright 2023 Design Barn Inc.\n */\n\nimport { DotLottieStateMachineCommon, type DotLottieStateMachineCommonOptions } from './common';\n\nexport class LottieStateMachine extends DotLottieStateMachineCommon {\n  public constructor(options: DotLottieStateMachineCommonOptions) {\n    super(options);\n  }\n}\n"]}