Cursor Rules â€” Theme & Brand Conventions

This document describes the conventions ("cursor rules") for working with theme and brand tokens in the `zero-to-app` design system. Follow these rules to keep the library aligned with Material Design 3 and maintainable.

1. Use M3 palette tokens (no legacy aliases)
- Always prefer Material 3 color roles defined on `brand.colors` (e.g. `primary`, `onPrimary`, `surface`, `onSurface`, `outlineVariant`, etc.).
- Do not add or consume legacy tokens such as `backgroundColor`, `color`, `borderColor`, `highlightColor`, `buttonText`, `cardBackgroundColor`, or `appbarBackgroundColor`.

2. Prefer semantic tokens for components
- Use `theme.values.tokens.*` where available (e.g. `tokens.button.primaryBg`, `tokens.input.placeholder`, `tokens.typography.title`).
- Semantic tokens allow future palette changes without editing component internals.

3. Theme access
- Use `useTheme()` to access theme values and helpers in components:
  - `const { values, mode, toggleTheme, setMode } = useTheme();`
- Use `useBrand()` to access raw brand configuration when you need non-theme values (fonts, spacing, logos).

4. Adding new tokens
- Add new color roles only when necessary and document them in `theme/themeConfig.ts`.
- If a token is cross-cutting (used by many components), add it to `tokens` rather than ad-hoc in components.

5. Typography
- Use `tokens.typography` (headline/title/body/label/caption) for semantic font sizes.
- If you need additional typographic control (weights, line-heights), add `tokens.typography.weights` and `tokens.typography.lineHeights`.

6. Dark mode and system preference
- `ThemeContext` exposes `mode: 'light' | 'dark'` and `setMode()`; prefer `mode` checks over `values.isDark` when possible.
- Consider following system color scheme at the app level and expose a `followSystem` option if needed.

7. Types and safety
- When adding tokens, update `ThemeValuesType` and related types so TypeScript enforces usage.
- Keep theme derivation centralized in `createLightTheme` / `createDarkTheme`.

8. Documentation
- Update `README.md` with any new tokens and provide usage examples.
- Add small component code snippets where semantic tokens should be used.

9. Backwards compatibility
- Avoid adding temporary legacy shims. If you must support older apps, add clear migration notes in the README and remove shims in the next major release.

10. Review checklist for PRs touching theme
- Did you add/update types for new tokens? (`theme/themeConfig.ts`)
- Did you populate the token in both light and dark creators? (`createLightTheme` / `createDarkTheme`)
- Did you update consuming components to use semantic tokens? (`components/ui/*`, `components/*`)
- Did you update README + tests where applicable?

Following these rules keeps the system coherent, type-safe, and aligned with Material Design 3 best practices.
